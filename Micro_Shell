#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <sys/wait.h>

#define BUF_SIZE 10000

// --- Function prototypes ---
char* strip_extra_spaces(char* str);
char* replaceWord(const char* s, const char* oldW, const char* newW);
char* get_env_var(char *str);
char* new_out(char *str);
char* new_in(char *str);
char* new_err(char *str);
void strip_redirections(char *cmd);

int microshell_main(int argc, char **argv) {
 char buf[BUF_SIZE];
    char buf2[BUF_SIZE];
    int last_status = 0;

    while (1) {
        printf("Micro shell prompt > ");
        fflush(stdout);

        if (fgets(buf, BUF_SIZE, stdin) == NULL)
            return last_status;

        buf[strcspn(buf, "\n")] = 0;

        if (strcmp(buf, "exit") == 0) {
            printf("Good Bye\n");
            break;
        }

        if (strchr(buf, '=') != NULL) {
            char *var_assign = strdup(buf);
            if (!var_assign) {
                perror("strdup failed");
                last_status = 1;
                continue;
            }
            if (putenv(var_assign) != 0) {
                perror("putenv failed");
                last_status = 1;
                continue;
            }
            continue;
        }

        // expand env vars
        while (strchr(buf, '$') != NULL) {
            strcpy(buf2, buf);
            char *envvar = get_env_var(buf2);
            if (!envvar) break;
            char full_envvar[BUF_SIZE];
            char *value = getenv(envvar);
            snprintf(full_envvar, sizeof(full_envvar), "$%s", envvar);

            if (value) {
                char *new_buf = replaceWord(buf2, full_envvar, value);
                if (new_buf) {
                    strncpy(buf, new_buf, sizeof(buf) - 1);
                    buf[sizeof(buf) - 1] = '\0';
                    free(new_buf);
                }
            } else {
                char *new_buf = replaceWord(buf2, full_envvar, "");
                if (new_buf) {
                    strncpy(buf, new_buf, sizeof(buf) - 1);
                    buf[sizeof(buf) - 1] = '\0';
                    free(new_buf);
                }
            }
            free(envvar);
        }

        pid_t pid = fork();
        if (pid > 0) {
            int status;
            waitpid(pid, &status, 0);
            if (WIFEXITED(status)) last_status = WEXITSTATUS(status);
            else if (WIFSIGNALED(status)) last_status = 128 + WTERMSIG(status);
            else last_status = 1;
        } else if (pid == 0) {
            // ---------------- CHILD PROCESS ----------------

            char *pos_in  = strchr(buf, '<');
            char *pos_err = strstr(buf, "2>");
            char *pos_out = strchr(buf, '>');  // normal >

            int has_in  = (pos_in  != NULL);
            int has_err = (pos_err != NULL);
            int has_out = (pos_out != NULL);

            // stdout first
            if (has_out) {
                char *determined_out = new_out(buf);
                int out_fd = open(determined_out, O_WRONLY | O_CREAT | O_TRUNC, 0644);
                if (out_fd < 0) { fprintf(stderr, "%s: %s\n", determined_out, strerror(errno)); _exit(1);}
                dup2(out_fd, 1); close(out_fd); free(determined_out);
            }

            // input vs error order
            if (has_in && (!has_err || pos_in < pos_err)) {
                char *determined_in = new_in(buf);
                int in_fd = open(determined_in, O_RDONLY);
                if (in_fd < 0) { fprintf(stderr, "cannot access %s: %s\n", determined_in, strerror(errno)); _exit(1);}
                dup2(in_fd, 0); close(in_fd); free(determined_in);

                if (has_err) {
                    char *determined_err = new_err(buf);
                    int err_fd = open(determined_err, O_WRONLY | O_CREAT | O_TRUNC, 0644);
                    if (err_fd < 0) { fprintf(stderr, "cannot access %s: %s\n", determined_err, strerror(errno)); _exit(1);}
                    dup2(err_fd, 2); close(err_fd); free(determined_err);
                }
            } else {
                if (has_err) {
                    char *determined_err = new_err(buf);
                    int err_fd = open(determined_err, O_WRONLY | O_CREAT | O_TRUNC, 0644);
                    if (err_fd < 0) { fprintf(stderr, "cannot access %s: %s\n", determined_err, strerror(errno)); _exit(1);}
                    dup2(err_fd, 2); close(err_fd); free(determined_err);
                }

                if (has_in) {
                    char *determined_in = new_in(buf);
                    int in_fd = open(determined_in, O_RDONLY);
                    if (in_fd < 0) { fprintf(stderr, "cannot access %s: %s\n", determined_in, strerror(errno)); _exit(1);}
                    dup2(in_fd, 0); close(in_fd); free(determined_in);
                }
            }

            strip_redirections(buf);

            int argc2 = 0;
            char **newargv = NULL;
            char *token = strtok(buf, " \t");
            while (token != NULL) {
                char **tmp = (char **)realloc(newargv, sizeof(char *) * (argc2 + 2));
                if (!tmp) _exit(1);
                newargv = tmp;
                newargv[argc2] = strdup(token);
                if (!newargv[argc2]) _exit(1);
                argc2++;
                token = strtok(NULL, " \t");
            }
            if (!newargv) _exit(1);
            newargv[argc2] = NULL;

            execvp(newargv[0], newargv);
            fprintf(stderr, "%s: command not found\n", newargv[0]);
            _exit(127);
        } else {
            perror("fork failed");
            last_status = 1;
        }
    }

    return last_status;
}
  }


// Remove extra spaces from a string
char *strip_extra_spaces(char* str) {
    int i, x;
    for (i = x = 0; str[i]; ++i) {
        if (!isspace((unsigned char)str[i]) || 
            (i > 0 && !isspace((unsigned char)str[i-1]))) {
            str[x++] = str[i];
        }
    }
    str[x] = '\0';
    return str;
}

// Replace all occurrences of oldW with newW in string s
char* replaceWord(const char* s, const char* oldW, const char* newW) {
    char* result;
    int i, cnt = 0;
    int newWlen = strlen(newW);
    int oldWlen = strlen(oldW);
    int len = strlen(s);

    // Count occurrences of oldW
    for (i = 0; s[i] != '\0'; i++) {
        if (strstr(&s[i], oldW) == &s[i]) {
            cnt++;
            i += oldWlen - 1;
        }
    }

    // Allocate memory for new string
    result = (char*)malloc(len + cnt * (newWlen - oldWlen) + 1);
    if (!result) return NULL;

    i = 0;
    while (*s) {
        if (strstr(s, oldW) == s) {
            strcpy(&result[i], newW);
            i += newWlen;
            s += oldWlen;
        } else {
            result[i++] = *s++;
        }
    }
    result[i] = '\0';
    return result;
}

// Extract the environment variable name after '$'
char* get_env_var(char *str) {
    char *pos = strchr(str, '$');
    if (pos != NULL) {
        pos++;  // skip '$'
        char *end = pos;
        while (*end && (isalnum((unsigned char)*end) || *end == '_')) end++;
        size_t len = end - pos;
        char *sub = (char*)malloc(len + 1);
        if (!sub) return NULL;
        strncpy(sub, pos, len);
        sub[len] = '\0';
        return sub;
    }
    return NULL;
}

// ----------------- Redirection Functions -----------------

// Determine output file for '>'
char *new_out(char *str) {
    char *pos = strchr(str, '>');
    if (!pos) return NULL;
    pos++; // skip '>'

    while (isspace((unsigned char)*pos)) pos++;

    char *start = pos;
    while (*pos && !isspace((unsigned char)*pos) && *pos != '>' && *pos != '<') pos++;

    size_t len = pos - start;
    char *fname = (char*)malloc(len + 1);
    if (!fname) return NULL;
    strncpy(fname, start, len);
    fname[len] = '\0';
    return fname;
}

// Determine input file for '<'
char *new_in(char *str) {
    char *pos = strchr(str, '<');
    if (!pos) return NULL;
    pos++; // skip '<'

    while (isspace((unsigned char)*pos)) pos++;

    char *start = pos;
    while (*pos && !isspace((unsigned char)*pos) && *pos != '>' && *pos != '<') pos++;

    size_t len = pos - start;
    char *fname = (char*)malloc(len + 1);
    if (!fname) return NULL;
    strncpy(fname, start, len);
    fname[len] = '\0';
    return fname;
}

// Determine error redirection file for '2>'
char *new_err(char *str) {
    char *pos = strstr(str, "2>");
    if (!pos) return NULL;
    pos += 2; // skip "2>"

    while (isspace((unsigned char)*pos)) pos++;

    char *start = pos;
    while (*pos && !isspace((unsigned char)*pos) && *pos != '>' && *pos != '<') pos++;

    size_t len = pos - start;
    char *fname = (char*)malloc(len + 1);
    if (!fname) return NULL;
    strncpy(fname, start, len);
    fname[len] = '\0';
    return fname;
}

// Remove all redirection operators and filenames from command
void strip_redirections(char *cmd) {
    char result[BUF_SIZE];
    int i = 0, j = 0;

    while (cmd[i] != '\0') {
        // Skip '2> file'
        if (cmd[i] == '2' && cmd[i+1] == '>') {
            i += 2;
            while (isspace((unsigned char)cmd[i])) i++;
            while (cmd[i] != '\0' && !isspace((unsigned char)cmd[i])) i++;
            continue;
        }

        // Skip '> file'
        if (cmd[i] == '>') {
            i++;
            while (isspace((unsigned char)cmd[i])) i++;
            while (cmd[i] != '\0' && !isspace((unsigned char)cmd[i])) i++;
            continue;
        }

        // Skip '< file'
        if (cmd[i] == '<') {
            i++;
            while (isspace((unsigned char)cmd[i])) i++;
            while (cmd[i] != '\0' && !isspace((unsigned char)cmd[i])) i++;
            continue;
        }

        // Copy normal characters
        result[j++] = cmd[i++];
    }

    result[j] = '\0';
    strcpy(cmd, result);
}
